// "Не хочешь отправиться в путешествие, Ишак?"

// Дана непустая строка S, длина которой N не превышает 10^6. Будем считать, что элементы
// строки нумеруются от 0 до N-1.

// Для каждой позиции i символа в строке нас будет интересовать подстрока, заканчивающаяся
// в этой позиции, и совпадающая с некоторым началом всей строки.

// Вообще говоря, таких подстрок будет несколько, не меньше двух. Самая длинная из них имеет
// длину i + 1, она нас интересовать не будет. А будет нас интересовать самая длинная из
// остальных таких подстрок (заметим, что такая подстрока всегда существует — в крайнем
// случае, если ничего больше не найдется, сгодится пустая подстрока).

// Значением префикс-функции prefix[i] будем считать длину этой подстроки.
// Префикс-функция используется в различных алгоритмах обработки строк. В частности,
// с её помощью можно быстро решать задачу о поиске вхождения одной строки в другую 
// («поиск образца в тексте»).

// Требуется для всех i от 0 до N-1 вычислить prefix[i].


#include <iostream>
#include <string>
#include <vector>

std::vector<size_t> PrefixFunction(const std::string& str) {
  std::vector<size_t> prefix(str.size(), 0);

  size_t size = prefix.size();
  size_t k = 0;

  for (size_t i = 1; i < size; ++i) {
    k = prefix[i - 1];

    while ((k > 0) && (str[k] != str[i])) {
      k = prefix[k - 1];
    }

    if (str[k] == str[i]) {
      prefix[i] = k + 1;
    } else {
      prefix[i] = 0;
    }
  }
  
  return prefix;
}

int main() {
  std::string str;
  std::cin >> str;
  
  std::vector<size_t> prefix = PrefixFunction(str);

  for (size_t i = 0; i < prefix.size(); ++i) {
    std::cout << prefix[i] << ' ';
  }

  return 0;
}