// # include "отказ_от_авторских_прав.h"
// Поможем Джоан Роулинг развить сюжетную дыру, связанную с маховиками времени. После битвы с
// тем-кого-нельзя-называть магия вышла на качественно новый уровень. Теперь маховики времени
// способны не только переносить назад во времени, но и в принципе перемещаться в любую
// заданную точку мира в любой заданный момент времени. В связи с тем, что это могло бы
// вызвать хаос, Министерство Магии решило наложить некоторые ограничения на них.
// А именно, есть N магических станций, в которых возможно использование маховиков, при этом
// любая телепортация может совершаться только в один из этих пунктов. При этом для
// телепортаций есть определенное расписание. Можно сравнить это с магловскими авиаперелетами,
// только время работает на руку волшебникам.
// Легенда закончена, теперь сама задача. В момент времени 0 вы находитесь в магической
// станции A. Вам дано расписание рейсов. Требуется оказаться в магической станции B как можно
// раньше (то есть в наименьший возможный момент времени).
// При этом разрешается делать сложные маршруты, использующие несколько магических станций.
// Если вы прибываете на некоторую станцию в момент времени T, то вы можете телепортироваться
// из него любым рейсом, который отправляется из этой станции в момент времени T или позднее
// (но не раньше).

// В первой строке вводится число N — количество магических станций (1 ≤ N ≤ 1000). Вторая
// строка содержит два числа A и B — номера начальной и конечной станций. В третьей строке
// задается K — количество всевозможных телепортаций (0 ≤ K ≤ 1000).
// Следующие K строк содержат описания телепортаций, по одной на строке. Каждое описание
// представляет собой четверку целых чисел. Первое число каждой четверки задает номер станции
// отправления, второе — время отправления, третье — станция назначения, четвертое — время
// прибытия. Номера станций — натуральные числа из диапазона от 1 до N.
// Станции назначения и отправления могут совпадать (да-да, петли в пространстве и времени).
// Время измеряется в некоторых магических единицах и задается целым числом, по модулю не
// превышающим 109. Поскольку телепортации совершаются с использованием маховиков времени, то
// время прибытия может быть как больше времени отправления, так и меньше, или равным ему.
// Гарантируется, что входные данные таковы, что добраться из станции A до станции B всегда
// можно.

// Выведите минимальное время, когда вы сможете оказаться в пункте B.

#include <iostream>
#include <vector>

class Potteriana {
 private:
  struct Edge {
    int64_t beg_;
    int64_t dst_;
    int64_t time_start_;
    int64_t time_arrive_;

    Edge(const int64_t& beg, const int64_t& dst, const int64_t& start, const int64_t& arrive)
        : beg_(beg), dst_(dst), time_start_(start), time_arrive_(arrive) {
    }
  };

  std::vector<Edge> edges_;
  int64_t size_;

  int64_t start_;
  int64_t finish_;

  bool Relax(std::vector<std::pair<int64_t, int64_t> >& min_times, const Edge& edge) {
    if ((min_times[edge.beg_].first != 100000000000000) && (min_times[edge.beg_].first <= edge.time_start_) &&
        (min_times[edge.dst_].second > edge.time_arrive_)) {
      min_times[edge.dst_].first = edge.time_arrive_;
      min_times[edge.dst_].second = edge.time_arrive_;

      return true;
    }

    return false;
  }

 public:
  Potteriana() {
    std::cin >> start_ >> finish_;
    --start_;
    --finish_;

    int64_t count = 0;
    std::cin >> count;
    edges_.reserve(count);
    size_ = count;

    int64_t first = 0;
    int64_t time_first = 0;
    int64_t second = 0;
    int64_t time_second = 0;

    for (int64_t i = 0; i < count; ++i) {
      std::cin >> first >> time_first >> second >> time_second;
      --first;
      --second;

      edges_.emplace_back(Edge(first, second, time_first, time_second));
    }
  }

  // using Bellman-Ford algorithm
  void TheTime(const int& n) {
    std::vector<std::pair<int64_t, int64_t> > min_times(n,
                                                        std::pair<int64_t, int64_t>(100000000000000, 100000000000000));
    min_times[start_].first = 0;
    min_times[start_].second = 0;

    bool relaxed = false;

    for (int64_t k = 0; k < size_; ++k) {
      for (auto& edge : edges_) {
        if (Relax(min_times, edge)) {
          relaxed = true;
        }
      }

      if (!relaxed) {
        break;
      }
    }

    std::cout << min_times[finish_].first << "\n";
  }
};

int main() {
  int64_t n = 0;
  std::cin >> n;

  Potteriana flywheels;

  flywheels.TheTime(n);

  return 0;
}